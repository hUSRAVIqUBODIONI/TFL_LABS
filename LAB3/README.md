
# **LL(1) Parser (with Left Recursion Elimination and Right Factoring)**

Реализовал парсер для LL(1)

## **Описание**

Проект состоит из нескольких ключевых шагов:
1. **Устранение левой рекурсии**: Переписывание правил грамматики, чтобы избежать ситуаций, где нетерминал непосредственно вызывает себя в левой части продукции.
2. **Устранение правого факторинга**: Преобразование грамматик с общими префиксами в более читаемую форму, чтобы упростить парсинг.
3. **Вычисление множества First**: Для каждого нетерминала вычисляются множества терминалов, которые могут быть первыми символами в строке, порожденной этим нетерминалом.
4. **Вычисление множества Follow**: Для каждого нетерминала вычисляется множество символов, которые могут следовать после его использования в правиле продукции.
5. **Построение таблицы синтаксического анализа (парсинг-таблицы)**: Создание таблицы, которая определяет, какое правило грамматики следует применить в зависимости от текущего символа входной строки.

## **Основные функции**

- **eliminate_left_recursion(g::Grammar, grammar)**  
  Убирает левую рекурсию из заданной грамматики.

- **eliminate_right_factoring(g::Grammar)**  
  Убирает правой факторинг из грамматики.

- **find_first(g::Grammar)**  
  Вычисляет множество `First` для каждого нетерминала.

- **find_follow(g::Grammar)**  
  Вычисляет множество `Follow` для каждого нетерминала.

- **create_parser_table(g::Grammar)**  
  Создает таблицу парсера для синтаксического анализа входной строки.

- **parse_word(g::Grammar, input_string)**  
  Разбирает строку `input_string` с использованием созданной таблицы парсера.

## **Основные структуры данных**

- **Grammar**: Представление грамматики, включая множество правил продукции (P), множество нетерминалов (N), терминалов (T), а также таблицы `First`, `Follow` и парсинга.

```julia
mutable struct Grammar
    P::OrderedDict{String, OrderedSet{Vector{String}}}  # Правила продукции
    N::OrderedSet{String}  # Нетерминалы
    T::OrderedSet{String}  # Терминалы
    parse_table::OrderedDict{String, OrderedDict{String,OrderedSet{Vector{String}}}}  # Таблица парсинга
    Firsts::OrderedDict{String, OrderedSet{String}}  # Множество First для каждого нетерминала
    Follow::OrderedDict{String, OrderedSet{String}}  # Множество Follow для каждого нетерминала
end

## **Пример**

### Входная грамматика:

```julia
grammar = OrderedDict(
    "E" => ["E + T", "T"],
    "T" => ["T * F", "F"],
    "F" => ["n", "( E )"]
)

input_string = "n * ( n + n )"
```
__результат__ - ___true___
 

