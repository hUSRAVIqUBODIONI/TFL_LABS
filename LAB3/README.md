# **LL(k) Парсер (с устранением левой рекурсии и правого факторинга)**

Этот проект реализует LL(k) парсер с поддержкой значений `1 <= k <= 3`. Парсер предназначен для работы с контекстно-свободными грамматиками (CFG) и поддерживает устранение левой рекурсии и правого факторинга. Основная цель — предоставить эффективный и систематический способ синтаксического анализа строк на основе заданной грамматики с использованием техники парсинга LL(k).

## **Особенности**
1. **Устранение левой рекурсии**: Преобразует грамматики, содержащие левую рекурсию, в эквивалентные грамматики без левой рекурсии. Левая рекурсия может привести к бесконечной рекурсии в верхне-доонных парсерах, таких как LL-парсеры.
2. **Устранение правого факторинга**: Обрабатывает правила грамматики с общими префиксами, вынося их для упрощения парсинга и предотвращения неоднозначности.
3. **Вычисление множества First**: Вычисляет множества `First` для всех нетерминалов. Эти множества представляют собой возможные первые символы в строках, порожденных нетерминалом.
4. **Вычисление множества Follow**: Вычисляет множества `Follow` для всех нетерминалов. Эти множества представляют собой возможные символы, которые могут следовать после использования нетерминала в правиле продукции.
5. **Построение таблицы парсинга**: Создает таблицу парсинга LL(k) на основе множества `First` и `Follow`.
6. **Парсинг строки**: Использует таблицу парсинга для анализа и парсинга входной строки в соответствии с заданной грамматикой.

## **Ключевые концепции**
- **LL(k) Парсинг**: LL-парсеры используют метод сверху вниз для синтаксического анализа строки слева направо и могут заглядывать вперед на `k` символов, чтобы принять решение о применении правила продукции. Цель — применить правильное правило продукции, исходя из текущего нетерминала и символов в буфере.
- **Левая рекурсия**: Грамматика называется лево-рекурсивной, если нетерминал может в конечном итоге привести к себе самому как первому символу в продукции. Такая грамматика должна быть преобразована для работы с LL-парсером.
- **Правой факторинг**: Если у нетерминала есть несколько продукций с общим префиксом, то применяется правой факторинг, чтобы сделать грамматику более однозначной и упрощенной для парсинга.

## **Структуры данных**

- **Grammar**: Основная структура для представления грамматики. Она включает в себя:
  - `P`: Словарь правил продукции, где для каждого нетерминала хранится множество возможных правых частей продукций.
  - `N`: Множество нетерминалов.
  - `T`: Множество терминалов.
  - `Firsts`: Словарь, содержащий множества `First` для каждого нетерминала.
  - `Follow`: Словарь, содержащий множества `Follow` для каждого нетерминала.
  - `parse_table`: Таблица парсинга LL(k), которая используется для синтаксического анализа.

## **Функции**

- **`eliminate_left_recursion(g::Grammar, grammar)`**: Устраняет левую рекурсию из грамматики.
- **`eliminate_right_factoring(g::Grammar)`**: Устраняет правой факторинг из грамматики.
- **`find_first(g::Grammar)`**: Вычисляет множества `First` для всех нетерминалов грамматики.
- **`find_follow(g::Grammar)`**: Вычисляет множества `Follow` для всех нетерминалов грамматики.
- **`create_parser_table(g::Grammar)`**: Строит таблицу парсинга LL(k) на основе множества `First` и `Follow`.
- **`parse_word(g::Grammar, input_string)`**: Выполняет синтаксический анализ строки с использованием таблицы парсинга LL(k) и заданной грамматики.

## **Использование**

1. **Создание грамматики**:
   Определите грамматику в виде набора правил продукции с помощью `OrderedDict`. Каждое правило состоит из левой части (нетерминал) и правой части (продукция).

   Пример грамматики:

   ```julia
   grammar_str = """
   S -> A B | C D
   A -> a
   B -> b
   C -> c
   D -> d
   """
